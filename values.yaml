# Default values for test-web.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: nginx
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: "nginx"
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: test.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# Add LogStash Sidecar
logstash:
  enabled: true
  image: logstash
  tag: 8.12.2
  resources: {}
  volumeMounts: []
  # Access Elastic Search with SSL enabled
  # pipeline example
  # output {
  # ...
  #   hosts => ["https://elasticsearch-master.svc.elastic:9200"]
  #   cacert => "/usr/share/logstash/config/certs/ca.crt"
  # ...
  # }
  esCert:
    enabled: false
    # get elasticsearch self-signed CA, type below (assuming secret name is elasticsearch-master-certs and default namespace)
    # kubectl get secret elasticsearch-master-certs -o jsonpath="{.data.ca\.crt}" | base64 --decode
    secretName: "elasticsearch-ca-secret"
    caData: |
      -----BEGIN CERTIFICATE-----
      MIIDITCCAgmgAwIBAgIQffwZqYaHBCJggklZW9mnbDANBgkqhkiG9w0BAQsFADAb
      MRkwFwYDVQQDExBlbGFzdGljc2VhcmNoLWNhMB4XDTI0MDMxNTE1MDQ0MFoXDTI1
      MDMxNTE1MDQ0MFowGzEZMBcGA1UEAxMQZWxhc3RpY3NlYXJjaC1jYTCCASIwDQYJ
      KoZIhvcNAQEBBQADggEPADCCAQoCggEBAMhvCLJBbTL7zrdU/mZQbMQXUGsNVCZ1
      MmzA5ZN+Y/6OPogIiCQewxKIL7FkxuCoq00qUBL8TDNWzgvZcyOFrIkJq4ceMcLV
      dif2LCJOeW2TCsAQOKvB0ZiDUyTzaIhPfx3kTxGQAjYo/tkR7i4qS8k8JV2foPH3
      iqSFGSuDtCdw2AW9GJUVcVwpOy4izdpnM3a7ep39y50qOvismRzvnLjRwX0QJ+xu
      kOaw/Sphn/p4S3ZQgVsHlv4yDes+EWo7OjpDMmnuMBihPDVV3JY+xfstUaEk7dV9
      8N8d+v5bnjfX/PnTCYwYnFL9q1CGazcsEkCyscmcT02IcDdkcgb9s18CAwEAAaNh
      MF8wDgYDVR0PAQH/BAQDAgKkMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcD
      AjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRRwTe78irABRppKHkSqxKIkT/l
      RzANBgkqhkiG9w0BAQsFAAOCAQEAUwv13VIeybetavsiHWkD2h2iRxp+KIpiD5Ua
      LR3EuURfDOII4z/8hnYD8QEcEI0d8bSj3k9GVDb5xcj3cS54WyHFm4XfB9kg/PEA
      4phWspgvAZ/0JCpgmMmZHaDzlVPQBohtOpvTF8Mov+cX6Bex9+sX4iJMQbtSot8u
      g4dp/ukd+3X8IERwGhIH/8EHnpDKz9fnEVSKedfdiUJMkzckAyNcFxKsh/JyeG1x
      SIwLbOIJc1YAcKalkrrqITCHNB69qMOAr6FOmRsbzD0Efk9Q6zrU+ABWv2kBpeKy
      zWR9av8rkT6zu7orKGLxUFvZKPuYwgEsAkv/L9TtRTJgX6qGZQ==
      -----END CERTIFICATE-----


  setting: |
    http.host: "0.0.0.0"
    xpack.monitoring.elasticsearch.hosts: [ "https://elasticsearch-master.elastic.svc:9200" ]
    xpack.monitoring.elasticsearch.ssl.certificate_authority: "/usr/share/logstash/config/certs/ca.crt"
  # default pipelines.yml
  pipelines: |
    # This file is where you define your pipelines. You can define multiple.
    # For more information on multiple pipelines, see the documentation:
    #   https://www.elastic.co/guide/en/logstash/current/multiple-pipelines.html
    - pipeline.id: main
      path.config: "/usr/share/logstash/pipeline"
  # Pipeline Implementation
  pipelineImpl:
    pipeline.conf: |
      input {
        file {
          path => "/opt/logs/access.log"
          start_position => "beginning"
        }
      }
      output {
        stdout {
          codec => rubydebug
        }
      }



resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}

tolerations: []

affinity: {}
